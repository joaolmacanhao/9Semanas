ğŸ“˜ Sobre o RepositÃ³rio

Este repositÃ³rio foi criado para versionar todos os cÃ³digos desenvolvidos durante uma trilha de estudos de 9 semanas, baseada na aula disponibilizada pela Attekita Dev - 

ğŸ“ Link da referÃªncia: https://www.youtube.com/watch?v=rg6YB4LvNcg&t=225s

Atualmente estudo Java de forma nativa e atuo profissionalmente em uma empresa que utiliza C# (.NET) e o ecossistema Microsoft.
Dessa forma, para atender tanto aos objetivos didÃ¡ticos quanto profissionais, executarei a trilha em Java e C# simultaneamente.

ğŸ§­ Estrutura e Metodologia

A trilha foi planejada para ser concluÃ­da em 9 semanas, com estudos diÃ¡rios e prÃ¡tica constante.
Os exercÃ­cios serÃ£o resolvidos principalmente no LeetCode. 

Para organizaÃ§Ã£o e clareza:

Cada problema resolvido terÃ¡ sua prÃ³pria classe, nomeada conforme o tÃ­tulo do problema.

As classes nÃ£o conterÃ£o main, pois serÃ£o executadas diretamente nas plataformas de desafio.

Cada classe incluirÃ¡ em comentÃ¡rios:

link do problema,

explicaÃ§Ã£o da lÃ³gica aplicada,

consideraÃ§Ãµes sobre performance,

insights e alternativas de soluÃ§Ã£o.

âœ… RecomendaÃ§Ãµes

Por preferÃªncia pessoal e boas prÃ¡ticas de aprendizado, nÃ£o recomendo o uso de IA para gerar soluÃ§Ãµes completas.

Use IA para:

âœ”ï¸ entender conceitos
âœ”ï¸ revisar sua lÃ³gica
âœ”ï¸ obter explicaÃ§Ãµes detalhadas
âœ”ï¸ comparar abordagens

Mas evite pedir a soluÃ§Ã£o pronta, preservando assim o desenvolvimento da sua habilidade lÃ³gica e resoluÃ§Ã£o de problemas.

ğŸ—“ï¸ Cronograma Sugerido â€” 9 Semanas

Cada dia contÃ©m tarefa prÃ¡tica + problema(s) LeetCode.

Notas:

Tente 30â€“60 minutos por problema.

Se travar: pense â†’ leia dicas â†’ veja discussÃ£o â†’ sÃ³ entÃ£o consulte a soluÃ§Ã£o.

Marque o progresso: â€œfeito / revisar / repetirâ€.

Por fim, a semana 9 foi estruturada pra botar pra quebrar mesmo...boa....

PS: UM PRESENTINHO EXTRA VOS AGUARDA AO FINAL...SUAVE COMO UMA SABUGADA...

ğŸ“ Semana 1 â€” Arrays & Strings (Fundamentos)
Dia 1 â€” Conceitos e ambiente

Ler: arrays em Java (sintaxe, Ã­ndices, length).

LeetCode: Two Sum (Easy)
ğŸ‘‰ https://leetcode.com/problems/two-sum/

Dia 2 â€” ManipulaÃ§Ã£o de arrays

PrÃ¡tica: varredura, soma, mÃ¡ximo/mÃ­nimo.

LeetCode: Best Time to Buy and Sell Stock (Easy)
ğŸ‘‰ https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

Dia 3 â€” Reverse / Palindrome (Strings)

PrÃ¡tica: inverter string manualmente; validar palÃ­ndromo.

LeetCode: Reverse String (Easy)
ğŸ‘‰ https://leetcode.com/problems/reverse-string/

Dia 4 â€” Substrings & Anagrams

PrÃ¡tica: substring, comparaÃ§Ã£o, anagram check.

LeetCode: Valid Anagram (Easy)
ğŸ‘‰ https://leetcode.com/problems/valid-anagram/

Dia 5 â€” Two Pointers

PrÃ¡tica: remover duplicados, soma alvo, manipulaÃ§Ã£o de Ã­ndices.

LeetCode: Two Sum II â€” Sorted (Easy)
ğŸ‘‰ https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

Dia 6 â€” AplicaÃ§Ã£o combinada

LeetCode: 3Sum (Medium)
ğŸ‘‰ https://leetcode.com/problems/3sum/

Dia 7 â€” RevisÃ£o

Refatorar: Two Sum + Reverse String.

ğŸ“ Semana 2 â€” Listas Ligadas, Pilhas e Filas
Dia 1 â€” Linked List bÃ¡sico

Implementar Node, add, remove, traverse.

LeetCode: Merge Two Sorted Lists (Easy)
ğŸ‘‰ https://leetcode.com/problems/merge-two-sorted-lists/

Dia 2 â€” Remove N-th / Ponteiros

LeetCode: Remove Nth Node From End of List (Medium)
ğŸ‘‰ https://leetcode.com/problems/remove-nth-node-from-end-of-list/

Dia 3 â€” Cycle Detection

LeetCode: Linked List Cycle (Easy)
ğŸ‘‰ https://leetcode.com/problems/linked-list-cycle/

Dia 4 â€” Pilha (Stack)

LeetCode: Valid Parentheses (Easy)
ğŸ‘‰ https://leetcode.com/problems/valid-parentheses/

Dia 5 â€” ExpressÃµes (Stack)

LeetCode: Evaluate Reverse Polish Notation (Medium)
ğŸ‘‰ https://leetcode.com/problems/evaluate-reverse-polish-notation/

Dia 6 â€” Filas e Deques

Implementar fila simples.

LeetCode: Design Circular Queue (Medium)
ğŸ‘‰ https://leetcode.com/problems/design-circular-queue/

Dia 7 â€” RevisÃ£o

RefaÃ§a Merge Lists e Cycle com testes.

ğŸ“ Semana 3 â€” Hash Tables & Sets
Dia 1 â€” HashMap bÃ¡sico

RefaÃ§a Two Sum usando HashMap (O(1)).

Dia 2 â€” FrequÃªncia de elementos

LeetCode: Top K Frequent Elements (Medium)
ğŸ‘‰ https://leetcode.com/problems/top-k-frequent-elements/

Dia 3 â€” Anagram Grouping

LeetCode: Group Anagrams (Medium)
ğŸ‘‰ https://leetcode.com/problems/group-anagrams/

Dia 4 â€” HashSet

LeetCode: Contains Duplicate (Easy)
ğŸ‘‰ https://leetcode.com/problems/contains-duplicate/

Dia 5 â€” Problema clÃ¡ssico

LeetCode: Longest Consecutive Sequence (Hard)
ğŸ‘‰ https://leetcode.com/problems/longest-consecutive-sequence/

Dia 6 â€” Implementar HashTable do zero
Dia 7 â€” RevisÃ£o + benchmarking
ğŸ“ Semana 4 â€” RecursÃ£o & Ãrvores (Fundamentos)
Dia 1 â€” RecursÃ£o

Fatorial, Fibonacci.

LeetCode: Climbing Stairs (Easy)
ğŸ‘‰ https://leetcode.com/problems/climbing-stairs/

Dia 2 â€” Backtracking

LeetCode: Permutations (Medium)
ğŸ‘‰ https://leetcode.com/problems/permutations/

Dia 3 â€” Binary Tree Traversal

LeetCode: Binary Tree Inorder Traversal (Easy)
ğŸ‘‰ https://leetcode.com/problems/binary-tree-inorder-traversal/

Dia 4 â€” BST

LeetCode: Validate Binary Search Tree (Medium)
ğŸ‘‰ https://leetcode.com/problems/validate-binary-search-tree/

Dia 5 â€” Tree Depth

LeetCode: Maximum Depth of Binary Tree (Easy)
ğŸ‘‰ https://leetcode.com/problems/maximum-depth-of-binary-tree/

Dia 6 â€” LCA

LeetCode: Lowest Common Ancestor (Medium)
ğŸ‘‰ https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

Dia 7 â€” RevisÃ£o

Criar testes para Ã¡rvores.

ğŸ“ Semana 5 â€” Collections AvanÃ§adas & I/O
Dia 1 â€” List, Set, Map
Dia 2 â€” OrdenaÃ§Ã£o

LeetCode: Sort Characters By Frequency (Medium)
ğŸ‘‰ https://leetcode.com/problems/sort-characters-by-frequency/

Dia 3 â€” Streams (Java 8)
Dia 4 â€” I/O (Arquivos)
Dia 5 â€” JSON (Gson/Jackson)
Dia 6 â€” Mini projeto (CRUD em memÃ³ria)
Dia 7 â€” RevisÃ£o
ğŸ“ Semana 6 â€” JDBC + PostgreSQL
Dia 1 â€” InstalaÃ§Ã£o + ConexÃ£o
Dia 2 â€” CRUD via JDBC
Dia 3 â€” TransaÃ§Ãµes
Dia 4 â€” DAO manual
Dia 5 â€” Testes de integraÃ§Ã£o
Dia 6 â€” Connection Pool (Hikari)
Dia 7 â€” RevisÃ£o
ğŸ“ Semana 7 â€” Projeto IntermediÃ¡rio

Mini sistema de tarefas
(CRUD completo + regras de negÃ³cio + testes + logging)

ğŸ“ Semana 8 â€” RevisÃ£o AvanÃ§ada + PadrÃµes de Projeto

Singleton â€¢ Factory â€¢ Strategy â€¢ MVC â€¢ Clean Code
Testes (JUnit + Mockito)

ğŸ—‚ Estrutura da Semana 9
ğŸ“Œ Dia 1 â€” Deploy Profissional
Conceitos que vocÃª vai dominar

O que Ã© deploy (e por que nÃ£o Ã© sÃ³ â€œsubir para a nuvemâ€)

Build, environment e configuraÃ§Ã£o por variÃ¡veis

DiferenÃ§a entre produÃ§Ã£o, homologaÃ§Ã£o e desenvolvimento

Ambientes imutÃ¡veis vs configurÃ¡veis

Deploy manual vs automatizado

PrÃ¡tica

Fazer o deploy do seu projeto (Spring, Node ou full-stack) em:

Render

Railway

Fly.io

Vercel (caso tenha front em React)

Meta do dia: sua API deve responder online com banco de dados conectado.

ğŸ“Œ Dia 2 â€” VariÃ¡veis de Ambiente e Arquitetura para ProduÃ§Ã£o
VocÃª vai aprender

O que Ã© .env e por que nÃ£o deve ir para o GitHub

Como configurar secrets

Como organizar variÃ¡veis sensÃ­veis:

Chaves JWT

DNS do banco

ConfiguraÃ§Ãµes de SMTP

Credenciais de APIs externas

PrÃ¡tica

Criar .env.example documentado

Ajustar seu projeto para nÃ£o depender de valores fixos no cÃ³digo

Meta do dia: seu repositÃ³rio terÃ¡ uma configuraÃ§Ã£o limpa, profissional e segura.

ğŸ“Œ Dia 3 â€” Logs Profissionais + Logs Estruturados
O iniciante faz:

console.log("deu erro")

O dev profissional faz:

Loga em nÃ­veis (debug, info, warn, error, fatal)

Padroniza logs (JSON structured logs)

Registra contexto (ID da requisiÃ§Ã£o, usuÃ¡rio, endpoint)

Evita expor informaÃ§Ãµes sensÃ­veis

Envia logs para serviÃ§os externos como:

Logtail

Grafana Loki

DataDog

Elastic Stack (ELK)

PrÃ¡tica

Implementar logs estruturados no projeto

Gerar logs de erro simulando falhas

Analisar logs para investigaÃ§Ã£o

Meta do dia: seus logs comeÃ§am a ter â€œcara de empresaâ€.

ğŸ“Œ Dia 4 â€” Monitoramento + Observabilidade
VocÃª vai entender

A diferenÃ§a entre:

Logging

Monitoring

Tracing

Metrics

Health checks

Por que empresas precisam disso para SLA

Monitoramento de API:

LatÃªncia

Consumo de memÃ³ria

Tempo de resposta

Erros 5xx e 4xx

Throughput (RPS)

Ferramentas sugeridas

Grafana

Prometheus

Health Check do Spring ou Express

Limites de CPU e memÃ³ria no Docker

PrÃ¡tica

Criar endpoint /health

Configurar algum monitoramento simples

Gerar grÃ¡ficos de latÃªncia ou erros

Meta do dia: vocÃª sabe avaliar se sua API estÃ¡ saudÃ¡vel.

ğŸ“Œ Dia 5 â€” CI/CD (AutomaÃ§Ã£o de Testes, Build e Deploy)
O que vocÃª aprende

Como funciona um pipeline real

Actions do GitHub

Testes automatizados antes do deploy

Build da aplicaÃ§Ã£o

Deploy automÃ¡tico ao merge na main

Versionamento semÃ¢ntico

Releases no GitHub

PrÃ¡tica

Criar pipeline:

Rodar testes

Rodar lint

Fazer build

Deploy automÃ¡tico

Meta do dia: sua aplicaÃ§Ã£o â€œvai para o ar sozinhaâ€ quando vocÃª faz commit.

ğŸ“Œ Dia 6 â€” Debug Profissional
Aprender a fazer debug como um dev contratado

Debug step-by-step

InspeÃ§Ã£o de variÃ¡veis

Breakpoints condicionais

Teste manual + automÃ¡tico

Como rastrear erros do usuÃ¡rio real

Como simular cenÃ¡rios de produÃ§Ã£o localmente

PrÃ¡tica

Simular um bug real

Localizar o bug usando logs e debugger

Documentar a correÃ§Ã£o (post-mortem)

Meta do dia: vocÃª consegue resolver problemas reais e explicar sua linha de raciocÃ­nio.

ğŸ“Œ Dia 7 â€” ProfissionalizaÃ§Ã£o do RepositÃ³rio

O repositÃ³rio final (que vocÃª pode enviar para recrutadores) deve conter:

Arquivos essenciais

README.md completo

project-architecture.md

api-docs.md

CONTRIBUTING.md

.env.example

Fluxo CI/CD documentado

Prints do monitoramento

Dentro do README

DescriÃ§Ã£o tÃ©cnica do projeto

Arquitetura (com diagrama simples)

Tecnologias usadas

Como rodar localmente

Como rodar em Docker

Como fazer deploy

Como testar

Chamadas da API

PrÃ¡tica

Criar documentaÃ§Ã£o clara e tÃ©cnica

Organizar o repositÃ³rio para parecer um projeto sÃ©rio de empresa

Meta do dia: qualquer pessoa consegue entender, rodar e contribuir no seu projeto.

ğŸ¯ Resultado Final da Semana 9

VocÃª sairÃ¡ com:

âœ” um projeto publicado em ambiente real

âœ” logs estruturados

âœ” monitoramento funcionando

âœ” pipeline CI/CD profissional

âœ” documentaÃ§Ã£o completa

âœ” repositÃ³rio pronto para vaga jÃºnior

âœ” experiÃªncia real de deploy e troubleshooting

Ou seja: vocÃª nÃ£o Ã© mais sÃ³ â€œalguÃ©m que codificaâ€.
VocÃª serÃ¡ alguÃ©m que sabe trabalhar em produÃ§Ã£o.

ğŸ”¥ INSANE MODE â€” VERSÃƒO FINAL, DEFINITIVA, NUCLEAR

100% MULTIPLATAFORMA â€” JAVA + ANGULAR + POSTGRES

(Mac, Windows e Linux: todos suportados, todos com instruÃ§Ãµes claras)

Agora sim: um ROADMAP COMPLETO, o mais insano, profissional e pronto-pro-mercado que existe.
Se vocÃª seguir isso, vocÃª vira BACKEND Java, FRONTEND Angular e DBA nÃ­vel iniciante, tudo ao mesmo tempo â€” e tudo rodando em QUALQUER sistema operacional.

Pegue a pipoca, porque agora vai:

ğŸš€ POR QUE ESTE ROAD SERVE PARA QUALQUER SISTEMA (MAC / WINDOWS / LINUX)?

Porque tudo foi pensado assim:

âœ”ï¸ 1. Nada depende de ferramentas exclusivas de uma plataforma

Exemplo:
âŒ SQL Server
âŒ IIS
âŒ Chocolatey
âœ”ï¸ PostgreSQL (universal)
âœ”ï¸ Docker (universal)
âœ”ï¸ Java JDK 17+ (universal)
âœ”ï¸ Node 18+ (universal)
âœ”ï¸ Angular (universal)

âœ”ï¸ 2. Ferramentas absolutamente iguais em todas as mÃ¡quinas

Docker Compose â†’ igual no Windows/Mac/Linux

Angular CLI â†’ igual no Windows/Mac/Linux

psql â†’ igual no Windows/Mac/Linux

Java â†’ igual no Windows/Mac/Linux

âœ”ï¸ 3. Todos os comandos e instalaÃ§Ãµes terÃ£o equivalentes

(Podemos montar PDFs separados por SO se quiser.)

ğŸ”¥ INSANE MODE â€“ SUPREMO (JAVA + ANGULAR + POSTGRES + MULTIPLATAFORMA)

Este mÃ³dulo Ã© um treinamento de forÃ§a total:

Backend corporativo: Java + Spring Boot

Frontend escalÃ¡vel: Angular

Banco profissional: Postgres

Docker para rodar em qualquer sistema

Arquitetura corporativa real

Projetos COMPLETOS

60+ desafios

Testes, padrÃµes, seguranÃ§a, CI/CD

Deploy

PadrÃ£o BANCO + API + UI (arquitetura corporativa padrÃ£o)

âš™ï¸ REQUISITOS MULTIPLATAFORMA

(garanto que funciona igual em qualquer OS)

âœ”ï¸ JAVA 17+

Instale via SDKMAN (Mac/Linux) ou via MSI (Windows)
Tudo funciona igual.

âœ”ï¸ Node 18+

Para Angular â€” universal.

âœ”ï¸ Angular CLI

npm i -g @angular/cli

âœ”ï¸ PostgreSQL

OpÃ§Ãµes:

Instalar local (instalador GUI no Windows e Mac; apt no Linux)

OU usar Docker (mÃ©todo recomendado e 100% universal)

âœ”ï¸ Docker + Docker Compose

Ã‰ o grande equalizador entre plataformas:
Se roda Docker â†’ roda igual.

ğŸ”¥ A PARTIR DAQUI, Ã‰ INSANO DE VERDADE

Abaixo estÃ¡ o MÃ“DULO FINAL, incluindo a parte Java, Angular e PostgreSQL na veia.

ğŸ§¨ BLOCO 1 â€” AMBIENTE MULTIPLATAFORMA PROFISSIONAL
ğŸŸ© Windows

Instalar WSL2, Ubuntu

Instalar Docker Desktop

Instalar Java + Node

Instalar Postgres OU rodar via Docker

VS Code ou IntelliJ

Angular CLI

ğŸ Mac

Brew: Java, Node, Postgres

Docker Desktop (Apple Silicon funciona normal)

VS Code ou IntelliJ

Angular CLI

ğŸ§ Linux

apt install openjdk-17

apt install nodejs

Docker Engine

docker compose plugin

Postgres apt install ou Docker

Angular CLI

Tudo testado, tudo padrÃ£o.

ğŸ”¥ BLOCO 2 â€” JAVA BACKEND (CORPORATIVO)

VocÃª vai construir APIs iguais Ã s usadas em governos, bancos, fintechs e empresas enterprise:

ğŸ“¦ Spring Boot Estruturado

Controllers

Services

Repositories

Entities

DTOs

Mappers

Profiles YAML

Tratamento de exceÃ§Ãµes global

Response padronizada

Logs estruturados

Testes unitÃ¡rios

Testcontainers para Postgres

ğŸ“¡ APIs REST sofisticadas

PaginaÃ§Ã£o

Filtros

Updates parciais (PATCH)

Upload de arquivos

AutenticaÃ§Ã£o via JWT + Refresh Token

RBAC (roles e permissÃµes)

ğŸ” SeguranÃ§a

Spring Security 6

AutorizaÃ§Ã£o refinada:

USER

MANAGER

ADMIN

ExpiraÃ§Ã£o avanÃ§ada

Tokens renovÃ¡veis

Logout com blacklist opcional

ğŸ§ª Testes

JUnit 5

Mockito

Testcontainers rodando Postgres real

80%+ de cobertura

ğŸ§¨ BLOCO 3 â€” ANGULAR FRONTEND (ESCALÃVEL, CORPORATIVO)
ğŸ¢ Estrutura empresarial

CoreModule

SharedModule

Feature Modules

ComponentizaÃ§Ã£o forte

Interfaces TypeScript claras

Angular Material (tabelas, diÃ¡logos, snackbar, etc.)

ğŸš€ Funcionalidades

Tela de login

Guard + Interceptor (JWT)

Renova token automÃ¡tico

Navbar responsiva

Dashboard com grÃ¡ficos

CRUD com formulÃ¡rios reativos

PaginaÃ§Ã£o real

Filtros dinÃ¢micos

Lazy loading

Arquitetura limpa de serviÃ§os

RequisiÃ§Ãµes tipadas (HttpClient)

ğŸ’¬ ComunicaÃ§Ã£o com Java

Http interceptors

Tratamento global de erros

Rotas privadas por role

Refresh Token automÃ¡tico

Mensagens de feedback

ğŸ§¨ BLOCO 4 â€” BANCO DE DADOS POSTGRES
ğŸ¦ Modelo REAL

VocÃª aprende:

NormalizaÃ§Ã£o

Ãndices

Chaves estrangeiras

Views

Stored procedures

Particionamento

Explain analyze

OtimizaÃ§Ã£o de queries

Tools

pgAdmin (universal)

TablePlus (Mac/Windows)

CLI psql (universal)

Docker Compose padrÃ£o para qualquer OS
services:
  postgres:
    image: postgres:16
    container_name: postgres_insane
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: insane_db
    ports:
      - "5432:5432"
    volumes:
      - ./pgdata:/var/lib/postgresql/data

ğŸ§¨ BLOCO 5 â€” 3 SISTEMAS COMPLETOS (FULLSTACK)

(Back-end Java + Front-end Angular + Postgres + Docker)

âœ”ï¸ 1. Sistema Completo â€” Lava Jato (o seu real)

Clientes

Agendamentos

FuncionÃ¡rios

Financeiro

RelatÃ³rios

WhatsApp Cloud API

RBAC (funcionÃ¡rio/admin)

Docker Compose orquestrando tudo

âœ”ï¸ 2. Sistema de Senhas com WebSocket

Spring WebSocket

Angular WebSocketService

Painel animado estilo TV

Chamada de senhas em tempo real

âœ”ï¸ 3. E-commerce Completo Enterprise Style

Cadastro de produtos

Carrinho

Checkout

Pagamento Pix fake

Painel admin

AutenticaÃ§Ã£o avanÃ§ada

Dashboard com grÃ¡ficos

ğŸ§¨ BLOCO 6 â€” DESAFIOS INSANOS (JAVA + ANGULAR + SQL)
ğŸ’€ Java

Criar cache Redis

Criar API em 3 camadas

Criar DTO + mapper + testes

Criar endpoint com paginaÃ§Ã£o eficiente

Criar exceÃ§Ãµes personalizadas

Criar upload de imagem com validaÃ§Ã£o

ğŸ’€ Angular

Criar tabela com infinite scroll

Criar componente customizado de loading

Criar modal de confirmaÃ§Ã£o reutilizÃ¡vel

Criar interceptor global de erros

Criar CRUD completo com validaÃ§Ã£o avanÃ§ada

ğŸ’€ PostgreSQL

Criar Ã­ndices personalizados

Criar tabela particionada

Criar views materializadas

Montar relatÃ³rios complexos

Otimizar consultas com explain analyze

ğŸ§¨ BLOCO 7 â€” DEVOPS E DEPLOY
ğŸ”§ Docker Compose Fullstack

Java

Angular

Postgres

Reverse proxy NGINX

ğŸš€ Deploy

GitHub Actions para CI/CD

Deploy no railway/render/vercel/fly.io

VariÃ¡veis de ambiente

Versionamento

Profiles dev/prod

ğŸ”¥ CONCLUSÃƒO

Agora vocÃª tem:
âœ”ï¸ O roadmap mais completo do mercado
âœ”ï¸ Pronto para qualquer OS
âœ”ï¸ Java full enterprise
âœ”ï¸ Angular corporativo
âœ”ï¸ PostgreSQL com nÃ­vel profissional
âœ”ï¸ TrÃªs projetos completos
âœ”ï¸ Testes
âœ”ï¸ SeguranÃ§a
âœ”ï¸ DevOps
âœ”ï¸ E mais de 60 desafios Ã©picos